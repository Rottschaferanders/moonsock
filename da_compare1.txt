struct JsonRpcWsClient {
    // ...
    pending_requests: Arc<Mutex<HashMap<u32, (oneshot::Sender<JsonRpcResponse>, PendingRequestId)>>>,
    dirty_requests: Arc<Mutex<Vec<(Instant, u32)>>>,
    has_dirty_requests: Arc<AtomicBool>,
}

impl JsonRpcWsClient {
    // ...

    async fn mark_pending_requests_as_dirty(&self, error_message: String) {
        let mut pending_requests = self.pending_requests.lock().await;
        if pending_requests.len() == 1 {
            // If there is only one pending request, send the error through the oneshot channel
            let (_, (tx, _)) = pending_requests.drain().next().unwrap();
            tx.send(JsonRpcResponse::ReturnedError(serde_json::Value::String(error_message))).ok();
        } else {
            // Mark all pending requests as dirty
            let now = Instant::now();
            let mut dirty_requests = self.dirty_requests.lock().await;
            for (id, (tx, _)) in pending_requests.iter_mut() {
                *tx = (tx.clone(), PendingRequestId::Dirty {
                    id: *id,
                    timeout: now + DEFAULT_SEND_LISTEN_TIMEOUT,
                    error_message: error_message.clone(),
                });
                dirty_requests.push((now + DEFAULT_SEND_LISTEN_TIMEOUT, *id));
            }
            self.has_dirty_requests.store(true, Ordering::SeqCst);
        }
    }

    async fn check_dirty_requests(&self) {
        if !self.has_dirty_requests.load(Ordering::SeqCst) {
            return;
        }
        let mut dirty_requests = self.dirty_requests.lock().await;
        let now = Instant::now();
        let mut pending_requests = self.pending_requests.lock().await;
        let mut count = 0;
        let mut ids_to_remove = Vec::new();
        for (timeout, id) in dirty_requests.iter() {
            if now >= *timeout {
                // Timeout has been reached, return the error message to the function
                if let Some((tx, PendingRequestId::Dirty {
                    id: _,
                    timeout: _,
                    error_message,
                })) = pending_requests.get_mut(id)
                {
                    count += 1;
                    let error_message = if count > 1 {
                        format!("Error: This error may not be associated with this request and may have originated from another. One of your requests had an id that the websocket server could not parse. There is probably something wrong with the way the websocket server is parsing ids. {}", error_message)
                    } else {
                        error_message.clone()
                    };
                    tx.send(JsonRpcResponse::ReturnedError(serde_json::Value::String(error_message))).ok();
                    ids_to_remove.push(*id);
                }
            }
        }
        // Remove the dirty requests from the vector and the pending requests map
        dirty_requests.retain(|(t, _)| *t > now);
        for id in ids_to_remove {
            pending_requests.remove(&id);
        }
        if dirty_requests.is_empty() {
            self.has_dirty_requests.store(false, Ordering::SeqCst);
        }
    }
}