struct JsonRpcWsClient {
    // ...
    pending_requests: Arc<Mutex<HashMap<u32, (oneshot::Sender<JsonRpcResponse>, PendingRequestId)>>>,
    dirty_requests: Arc<Mutex<Vec<(u32, Instant)>>>,
    has_dirty_requests: Arc<AtomicBool>,
}

impl JsonRpcWsClient {
    // ...

    async fn mark_pending_requests_as_dirty(&self, error_message: String) {
        let mut pending_requests = self.pending_requests.lock().await;
        if pending_requests.len() == 1 {
            // If there is only one pending request, send the error through the oneshot channel
            let (_, (tx, _)) = pending_requests.drain().next().unwrap();
            tx.send(JsonRpcResponse::ReturnedError(serde_json::Value::String(error_message))).ok();
        } else {
            // Mark all pending requests as dirty
            let now = Instant::now();
            for (id, (tx, _)) in pending_requests.iter_mut() {
                *tx = (tx.clone(), PendingRequestId::Dirty {
                    id: *id,
                    timeout: now + DEFAULT_SEND_LISTEN_TIMEOUT,
                    error_message: error_message.clone(),
                });
                self.dirty_requests.lock().await.push((*id, now + DEFAULT_SEND_LISTEN_TIMEOUT));
            }
            self.has_dirty_requests.store(true, Ordering::Relaxed);
        }
    }

    async fn check_dirty_requests(&self) {
        if !self.has_dirty_requests.load(Ordering::Relaxed) {
            return;
        }
        let now = Instant::now();
        let mut dirty_requests = self.dirty_requests.lock().await;
        let mut pending_requests = self.pending_requests.lock().await;
        dirty_requests.retain(|(id, timeout)| {
            if now >= *timeout {
                if let Some((tx, pending_request_id)) = pending_requests.get(id) {
                    if let PendingRequestId::Dirty {
                        id: _,
                        timeout: t,
                        error_message,
                    } = pending_request_id
                    {
                        if *t == *timeout {
                            let count = dirty_requests.iter().filter(|(i, t)| *t == *timeout).count();
                            let error_message = if count > 1 {
                                format!("Error: This error may not be associated with this request and may have originated from another. One of your requests had an id that the websocket server could not parse. There is probably something wrong with the way the websocket server is parsing ids. {}", error_message)
                            } else {
                                error_message.clone()
                            };
                            tx.send(JsonRpcResponse::ReturnedError(serde_json::Value::String(error_message))).ok();
                        }
                    }
                }
                false
            } else {
                true
            }
        });
        if dirty_requests.is_empty() {
            self.has_dirty_requests.store(false, Ordering::Relaxed);
        }
    }
}